## 4-2강 명령어 구조 및 명령어 디자인

<br>

### 명령어 디자인과 레지스트
저번시간에 레지스트는 16비트라고 지정했었다. 
따라서 명령어도 당연히 16비트가 된다. 
명령어가 그저, 더해라! 곱해라! 라는 단순 연산자만을 생각하기 쉬운데
사실 명령어는 일을시키기 위한 기본 정보다 다 담겨져 있다.
그 기본정보 들이란 이런것들이다. - 연산자, 저장소, 피연산자1, 피연산자2

<br>

### cpu디자인은 하드웨어 전문가의 몫?
명령어 해독은 ALU가 하게된다.
생각해보자, 명령어 모델이 구성되지 않은상태에서 ALU디자인을 할수있는가?
따라서 기계적인 cpu구조를 디자인하기에 앞서 명령어 디자인이 선행되어야 하며,
cpu를 디자인한다 함은 단순 하드웨어적 측면만이 아님을 알수있다.

<br>


### 명령어의 구조
1. 명령어는 16비트 이다.
2. 첫 2비트는 일단 넘어가자(나중에 배운다).
3. 그다음으로 오는 3비트에 연산자정보를 담는다. 우리는 단순한 4칙연산만을 대상으로 할것이므로 3비트 즉 8가지로도 충분하다.
4. 다음 3비트에 저장소 정보를 표시한다. 레지스터는 총 8개이므로 3비트로 충분하다.
5. 이에 필요 조건으로 cpu의 연산결과는 일단 레지스터에 저장이되고, 연산 결과의 저장소는 레지스터로 한정됨을 인지한다.
6. 다음 4비트와 그 다음 4비트에 피연산자의 정보를 담는다.
7. 피연산자는 레지스터가 될수도 있고, 숫자가 될수도 있다.
8. 레지스터와 숫자정보 구분을 위해 피연산자 맨 앞자리 비트를 이용한다.
9. 피연산자의 첫 비트가 1이면 레지스터 정보, 0이면 숫자라 약속 한다.
10. 그렇다면 피연산자에 할당된 비트는 총3비트에 불과한데, 그보다 더 큰 수에 대한 연산은 어떻게 처리할것인가?
11. 명령어에 따라서 명령어구조가 달라질수도 있다. 예) 피연산자가 1개인 경우

<br>

### CISK와 RISK
+ 명령어를 단순하게
명령어 조합이 단순한것을 RISK 
명령어 조합이 복잡할 수 있는것(즉 다양한)이 CISK다
<br>
제한사항이 따르겟지만 조합될수 있는 명령어 종류중 
가장 핵심적이고 많이 사용하는 것들만 모아서 단순화 한것이 RISK라 할수있다.
고성능 컴퓨터로 갈수록 RISK 명령어를 사용하는데 왜냐하면
CISK같은 경우 속도에 제한이 걸리기 때문이다. 왜 제한이 걸릴까?
<br>
++ 왜 RISK 구조로 가야하는가?
RISK같은 경우 Fetch , Decode , Excution은 각각의 단계가 1클럭이 소모된다.
하나의 명령을 실행하기 위해서 3클럭이 소모된다.
명령어 5을 실행시키기 위해서 15클럭이 소모된다 할수있다.
하지만 F D E의 로직은 서로 공통사항이 없으므로, 하나의 단계가 실행되는 와중에 다른단계가 실행되어도 큰문제는 없다.
<br>
다시말해
F D E
  F D E
    F D E 의 구조로 실행이 가능하며,
<br>
만약 5개의 명령어를 실행시킨다고 하면 7클럭이 소모된다는 것을 알수있다.
이를 일반화 하면, n개의 명령어를 실행시키기 위해서 n+2클럭이 소모된다는 것이다.
<br>
하지만 CISK의 경우 명령어에 따라 각 단계의 소모 클럭수가 달라지게 된다.
RISK와 같이 중첩 처리를 할수가 없게 되는것이다.