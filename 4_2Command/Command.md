## 4-2강 명령어 구조 및 명령어 디자인

<br>

### 명령어 디자인과 레지스트
저번시간에 레지스트는 16비트라고 지정했었다.<br> 
따라서 명령어도 당연히 16비트가 된다.<br>
명령어가 그저, 더해라! 곱해라! 라는 단순 연산자만을 생각하기 쉬운데<br>
사실 명령어는 일을시키기 위한 기본 정보다 다 담겨져 있다.<br>
그 기본정보 들이란 이런것들이다. - 연산자, 저장소, 피연산자1, 피연산자2

<br>

### cpu디자인은 하드웨어 전문가의 몫?
명령어 해독은 ALU가 하게된다.<br>
생각해보자, 명령어 모델이 구성되지 않은상태에서 ALU디자인을 할수있는가?<br>
따라서 기계적인 cpu구조를 디자인하기에 앞서 명령어 디자인이 선행되어야 하며,<br>
cpu를 디자인한다 함은 단순 하드웨어적 측면만이 아님을 알수있다.<br>

<br>


### 명령어의 구조
1. 명령어는 16비트 이다.
2. 첫 2비트는 일단 넘어가자(나중에 배운다).
3. 그다음으로 오는 3비트에 연산자정보를 담는다. 우리는 단순한 4칙연산만을 대상으로 할것이므로 3비트 즉 8가지로도 충분하다.
4. 다음 3비트에 저장소 정보를 표시한다. 레지스터는 총 8개이므로 3비트로 충분하다.
5. 이에 필요 조건으로 cpu의 연산결과는 일단 레지스터에 저장이되고, 연산 결과의 저장소는 레지스터로 한정됨을 인지한다.
6. 다음 4비트와 그 다음 4비트에 피연산자의 정보를 담는다.
7. 피연산자는 레지스터가 될수도 있고, 숫자가 될수도 있다.
8. 레지스터와 숫자정보 구분을 위해 피연산자 맨 앞자리 비트를 이용한다.
9. 피연산자의 첫 비트가 1이면 레지스터 정보, 0이면 숫자라 약속 한다.
10. 그렇다면 피연산자에 할당된 비트는 총3비트에 불과한데, 그보다 더 큰 수에 대한 연산은 어떻게 처리할것인가?
11. 명령어에 따라서 명령어구조가 달라질수도 있다. 예) 피연산자가 1개인 경우

<br>

### CISK와 RISK
+ 명령어를 단순하게<br>
명령어 조합이 단순한것을 RISK<br> 
명령어 조합이 복잡할 수 있는것(즉 다양한)이 CISK다<br>
<br>
제한사항이 따르겟지만 조합될수 있는 명령어 종류중<br>
가장 핵심적이고 많이 사용하는 것들만 모아서 단순화 한것이 RISK라 할수있다.<br>
고성능 컴퓨터로 갈수록 RISK 명령어를 사용하는데 왜냐하면<br>
CISK같은 경우 속도에 제한이 걸리기 때문이다. 왜 제한이 걸릴까?<br>
<br>
++ 왜 RISK 구조로 가야하는가?
RISK같은 경우 Fetch , Decode , Excution은 각각의 단계가 1클럭이 소모된다.<br>
하나의 명령을 실행하기 위해서 3클럭이 소모된다.<br>
명령어 5을 실행시키기 위해서 15클럭이 소모된다 할수있다.<br>
하지만 F D E의 로직은 서로 공통사항이 없으므로, 하나의 단계가 실행되는 와중에 다른단계가 실행되어도 큰문제는 없다.<br>
<br>
다시말해<br>
F D E<br>
  F D E<br>
    F D E 의 구조로 실행이 가능하며,<br>
<br>
만약 5개의 명령어를 실행시킨다고 하면 7클럭이 소모된다는 것을 알수있다.<br>
이를 일반화 하면, n개의 명령어를 실행시키기 위해서 n+2클럭이 소모된다는 것이다.<br>
<br>
하지만 CISK의 경우 명령어에 따라 각 단계의 소모 클럭수가 달라지게 된다.<br>
RISK와 같이 중첩 처리를 할수가 없게 되는것이다.<br>
